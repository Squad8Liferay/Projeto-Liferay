{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { State } from '../../State';\nimport { Direction } from '../constants';\nimport GestureHandler from './GestureHandler';\nconst DEFAULT_MAX_DURATION_MS = 800;\nconst DEFAULT_MIN_ACCEPTABLE_DELTA = 160;\nconst DEFAULT_DIRECTION = Direction.RIGHT;\nconst DEFAULT_NUMBER_OF_TOUCHES_REQUIRED = 1;\nexport default class FlingGestureHandler extends GestureHandler {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"numberOfPointersRequired\", DEFAULT_NUMBER_OF_TOUCHES_REQUIRED);\n    _defineProperty(this, \"direction\", DEFAULT_DIRECTION);\n    _defineProperty(this, \"maxDurationMs\", DEFAULT_MAX_DURATION_MS);\n    _defineProperty(this, \"minAcceptableDelta\", DEFAULT_MIN_ACCEPTABLE_DELTA);\n    _defineProperty(this, \"delayTimeout\", void 0);\n    _defineProperty(this, \"startX\", 0);\n    _defineProperty(this, \"startY\", 0);\n    _defineProperty(this, \"maxNumberOfPointersSimultaneously\", 0);\n    _defineProperty(this, \"keyPointer\", NaN);\n  }\n  init(ref, propsRef) {\n    super.init(ref, propsRef);\n  }\n  updateGestureConfig({\n    enabled = true,\n    ...props\n  }) {\n    super.updateGestureConfig({\n      enabled: enabled,\n      ...props\n    });\n    if (this.config.direction) {\n      this.direction = this.config.direction;\n    }\n    if (this.config.numberOfPointers) {\n      this.numberOfPointersRequired = this.config.numberOfPointers;\n    }\n  }\n  startFling() {\n    this.startX = this.tracker.getLastX(this.keyPointer);\n    this.startY = this.tracker.getLastY(this.keyPointer);\n    this.begin();\n    this.maxNumberOfPointersSimultaneously = 1;\n    this.delayTimeout = setTimeout(() => this.fail(), this.maxDurationMs);\n  }\n  tryEndFling() {\n    if (this.maxNumberOfPointersSimultaneously === this.numberOfPointersRequired && (this.direction & Direction.RIGHT && this.tracker.getLastX(this.keyPointer) - this.startX > this.minAcceptableDelta || this.direction & Direction.LEFT && this.startX - this.tracker.getLastX(this.keyPointer) > this.minAcceptableDelta || this.direction & Direction.UP && this.startY - this.tracker.getLastY(this.keyPointer) > this.minAcceptableDelta || this.direction & Direction.DOWN && this.tracker.getLastY(this.keyPointer) - this.startY > this.minAcceptableDelta)) {\n      clearTimeout(this.delayTimeout);\n      this.activate();\n      return true;\n    }\n    return false;\n  }\n  endFling() {\n    if (!this.tryEndFling()) {\n      this.fail();\n    }\n  }\n  onPointerDown(event) {\n    this.tracker.addToTracker(event);\n    this.keyPointer = event.pointerId;\n    super.onPointerDown(event);\n    this.newPointerAction();\n  }\n  onPointerAdd(event) {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.newPointerAction();\n  }\n  newPointerAction() {\n    if (this.currentState === State.UNDETERMINED) {\n      this.startFling();\n    }\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n    this.tryEndFling();\n    if (this.tracker.getTrackedPointersCount() > this.maxNumberOfPointersSimultaneously) {\n      this.maxNumberOfPointersSimultaneously = this.tracker.getTrackedPointersCount();\n    }\n  }\n  onPointerMove(event) {\n    this.tracker.track(event);\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n    this.tryEndFling();\n    super.onPointerMove(event);\n  }\n  onPointerUp(event) {\n    super.onPointerUp(event);\n    this.onUp(event);\n    this.keyPointer = NaN;\n  }\n  onPointerRemove(event) {\n    super.onPointerRemove(event);\n    this.onUp(event);\n  }\n  onUp(event) {\n    this.tracker.removeFromTracker(event.pointerId);\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n    this.endFling();\n  }\n  activate(force) {\n    super.activate(force);\n    this.end();\n  }\n  resetConfig() {\n    super.resetConfig();\n    this.numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n    this.direction = DEFAULT_DIRECTION;\n  }\n}","map":{"version":3,"names":["State","Direction","GestureHandler","DEFAULT_MAX_DURATION_MS","DEFAULT_MIN_ACCEPTABLE_DELTA","DEFAULT_DIRECTION","RIGHT","DEFAULT_NUMBER_OF_TOUCHES_REQUIRED","FlingGestureHandler","constructor","args","_defineProperty","NaN","init","ref","propsRef","updateGestureConfig","enabled","props","config","direction","numberOfPointers","numberOfPointersRequired","startFling","startX","tracker","getLastX","keyPointer","startY","getLastY","begin","maxNumberOfPointersSimultaneously","delayTimeout","setTimeout","fail","maxDurationMs","tryEndFling","minAcceptableDelta","LEFT","UP","DOWN","clearTimeout","activate","endFling","onPointerDown","event","addToTracker","pointerId","newPointerAction","onPointerAdd","currentState","UNDETERMINED","BEGAN","getTrackedPointersCount","onPointerMove","track","onPointerUp","onUp","onPointerRemove","removeFromTracker","force","end","resetConfig"],"sources":["C:\\projetoliferay\\telaprimeiroacesso\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\handlers\\FlingGestureHandler.ts"],"sourcesContent":["import { State } from '../../State';\nimport { Direction } from '../constants';\nimport { AdaptedEvent, Config } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\n\nconst DEFAULT_MAX_DURATION_MS = 800;\nconst DEFAULT_MIN_ACCEPTABLE_DELTA = 160;\nconst DEFAULT_DIRECTION = Direction.RIGHT;\nconst DEFAULT_NUMBER_OF_TOUCHES_REQUIRED = 1;\n\nexport default class FlingGestureHandler extends GestureHandler {\n  private numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n  private direction = DEFAULT_DIRECTION;\n\n  private maxDurationMs = DEFAULT_MAX_DURATION_MS;\n  private minAcceptableDelta = DEFAULT_MIN_ACCEPTABLE_DELTA;\n  private delayTimeout!: number;\n\n  private startX = 0;\n  private startY = 0;\n\n  private maxNumberOfPointersSimultaneously = 0;\n  private keyPointer = NaN;\n\n  public init(ref: number, propsRef: React.RefObject<unknown>): void {\n    super.init(ref, propsRef);\n  }\n\n  public updateGestureConfig({ enabled = true, ...props }: Config): void {\n    super.updateGestureConfig({ enabled: enabled, ...props });\n\n    if (this.config.direction) {\n      this.direction = this.config.direction;\n    }\n\n    if (this.config.numberOfPointers) {\n      this.numberOfPointersRequired = this.config.numberOfPointers;\n    }\n  }\n\n  private startFling(): void {\n    this.startX = this.tracker.getLastX(this.keyPointer);\n    this.startY = this.tracker.getLastY(this.keyPointer);\n\n    this.begin();\n\n    this.maxNumberOfPointersSimultaneously = 1;\n\n    this.delayTimeout = setTimeout(() => this.fail(), this.maxDurationMs);\n  }\n\n  private tryEndFling(): boolean {\n    if (\n      this.maxNumberOfPointersSimultaneously ===\n        this.numberOfPointersRequired &&\n      ((this.direction & Direction.RIGHT &&\n        this.tracker.getLastX(this.keyPointer) - this.startX >\n          this.minAcceptableDelta) ||\n        (this.direction & Direction.LEFT &&\n          this.startX - this.tracker.getLastX(this.keyPointer) >\n            this.minAcceptableDelta) ||\n        (this.direction & Direction.UP &&\n          this.startY - this.tracker.getLastY(this.keyPointer) >\n            this.minAcceptableDelta) ||\n        (this.direction & Direction.DOWN &&\n          this.tracker.getLastY(this.keyPointer) - this.startY >\n            this.minAcceptableDelta))\n    ) {\n      clearTimeout(this.delayTimeout);\n      this.activate();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private endFling() {\n    if (!this.tryEndFling()) {\n      this.fail();\n    }\n  }\n\n  protected onPointerDown(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    this.keyPointer = event.pointerId;\n\n    super.onPointerDown(event);\n    this.newPointerAction();\n  }\n\n  protected onPointerAdd(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.newPointerAction();\n  }\n\n  private newPointerAction(): void {\n    if (this.currentState === State.UNDETERMINED) {\n      this.startFling();\n    }\n\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n\n    this.tryEndFling();\n\n    if (\n      this.tracker.getTrackedPointersCount() >\n      this.maxNumberOfPointersSimultaneously\n    ) {\n      this.maxNumberOfPointersSimultaneously =\n        this.tracker.getTrackedPointersCount();\n    }\n  }\n\n  protected onPointerMove(event: AdaptedEvent): void {\n    this.tracker.track(event);\n\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n\n    this.tryEndFling();\n\n    super.onPointerMove(event);\n  }\n\n  protected onPointerUp(event: AdaptedEvent): void {\n    super.onPointerUp(event);\n    this.onUp(event);\n\n    this.keyPointer = NaN;\n  }\n\n  protected onPointerRemove(event: AdaptedEvent): void {\n    super.onPointerRemove(event);\n    this.onUp(event);\n  }\n\n  private onUp(event: AdaptedEvent): void {\n    this.tracker.removeFromTracker(event.pointerId);\n    if (this.currentState !== State.BEGAN) {\n      return;\n    }\n    this.endFling();\n  }\n\n  public activate(force?: boolean): void {\n    super.activate(force);\n    this.end();\n  }\n\n  protected resetConfig(): void {\n    super.resetConfig();\n    this.numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n    this.direction = DEFAULT_DIRECTION;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}